[gd_scene load_steps=8 format=2]

[ext_resource path="res://code/Projectile_gpu.gd" type="Script" id=1]
[ext_resource path="res://img/star_1.png" type="Texture" id=2]
[ext_resource path="res://code/collisionfx.gd" type="Script" id=5]

[sub_resource type="Shader" id=3]
code = "shader_type canvas_item;

uniform vec2 velocity;
uniform vec4 passed_color;
uniform float radius;

varying vec2 projectile_pos;
varying vec2 projectile_prior;
varying vec2 point_A;
varying vec2 point_B;
varying vec2 point_C;
varying vec2 point_D;
varying vec2 AB;
varying vec2 AD;

void vertex() {
	// maybe move this to CPU
	projectile_pos.x = WORLD_MATRIX[3][0]; // get projectile position from matrix
	projectile_pos.y = WORLD_MATRIX[3][1];
	projectile_prior = projectile_pos - velocity;
	mat2 rotation_matrix = mat2(vec2(0.0, -1.0), vec2(1.0, 0.0));
	vec2 rect_offset = normalize(velocity) * rotation_matrix;
	rect_offset *= radius;
	point_A = projectile_pos - rect_offset; // get hitbox rectangle
	point_B = projectile_pos + rect_offset;
	point_C = projectile_prior + rect_offset;
	point_D = projectile_prior - rect_offset;
	AB = point_B - point_A;
	AD = point_D - point_A;
}

void fragment() {
	COLOR = vec4(0,0,0,0);
	vec2 pixel_pos = FRAGCOORD.xy; // pixel position on screen
	pixel_pos.y = 540.0 - pixel_pos.y; // y0 at top of screen instead
	// formula for finding if a point is within a rectangle
	// (0<AM⋅AB<AB⋅AB) and (0<AM⋅AD<AD⋅AD)
	vec2 AM = pixel_pos - point_A;
	float AM_dot_AB = dot(AM, AB);
	float AM_dot_AD = dot(AM, AD);
	if ((0.0 <= AM_dot_AB && AM_dot_AB <= dot(AB, AB)) &&
		(0.0 <= AM_dot_AD && AM_dot_AD <= dot(AD, AD))) 
	{
		COLOR = passed_color;
	} else {
		float d = length(projectile_pos - pixel_pos); // distance of pixel from projectile
		float d2 = length(projectile_prior - pixel_pos); // distance of pixel from prior
		
		float delta = fwidth(d);
		float alpha = smoothstep(radius, radius+delta, d); // antialiasing
		float alpha2 = smoothstep(radius, radius+delta, d2);
		alpha = min(alpha, alpha2);
		COLOR = mix(vec4(passed_color.rgb,1.0), vec4(passed_color.rgb,0.0), alpha);
	}
		
		
		
		// if ((d < radius ) || (d2 < radius)) { COLOR = passed_color; }
		
		
		
		
		
		
		
		
}"

[sub_resource type="ShaderMaterial" id=4]
shader = SubResource( 3 )
shader_param/velocity = null
shader_param/passed_color = null
shader_param/radius = null

[sub_resource type="ImageTexture" id=5]
flags = 0
flags = 0
size = Vector2( 64, 64 )

[sub_resource type="ParticlesMaterial" id=2]
flag_disable_z = true
spread = 30.0
gravity = Vector3( 0, 0, 0 )
initial_velocity_random = 0.5
orbit_velocity = 0.0
orbit_velocity_random = 0.0

[node name="Projectile" type="Sprite"]
material = SubResource( 4 )
texture = SubResource( 5 )
script = ExtResource( 1 )

[node name="collisionfx" type="Particles2D" parent="."]
emitting = false
amount = 4
lifetime = 0.2
one_shot = true
explosiveness = 0.75
process_material = SubResource( 2 )
texture = ExtResource( 2 )
script = ExtResource( 5 )

[node name="Tween" type="Tween" parent="."]
