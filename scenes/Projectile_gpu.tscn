[gd_scene load_steps=8 format=2]

[ext_resource path="res://code/Projectile_gpu.gd" type="Script" id=1]
[ext_resource path="res://img/star_1.png" type="Texture" id=2]
[ext_resource path="res://code/collisionfx.gd" type="Script" id=5]

[sub_resource type="Shader" id=3]
code = "shader_type canvas_item;

uniform vec2 velocity;
uniform vec4 passed_color;
uniform float radius;

varying vec2 projectile_pos;
const float projectile_border = 1.5;

void vertex() {
	projectile_pos.x = WORLD_MATRIX[3][0]; // get projectile position from matrix
	projectile_pos.y = WORLD_MATRIX[3][1];
}

void fragment() {
	bool drawn = false;
	vec2 pixel_pos = FRAGCOORD.xy; // pixel position on screen
	pixel_pos.y = 540.0 - pixel_pos.y; // y0 at top of screen instead
	
	vec2 projectile_prior = projectile_pos - velocity; // where was projectile previous frame
	
	// projectile_pos -> projectile_prior is a line
	// radius is how thick the line should be (a rectangle)
	mat2 rotation_matrix = mat2(vec2(0.0, -1.0), vec2(1.0, 0.0));
	vec2 rect_offset = normalize(velocity) * rotation_matrix;
	rect_offset *= radius;
	vec2 point_A = projectile_pos - rect_offset;
	vec2 point_B = projectile_pos + rect_offset;
	vec2 point_C = projectile_prior + rect_offset;
	vec2 point_D = projectile_prior - rect_offset;
//	if (length(point_A - pixel_pos) < 2.0) { drawn = true; COLOR = vec4(1,0,0,1) }
//	if (length(point_B - pixel_pos) < 2.0) { drawn = true; COLOR = vec4(0,1,0,1) }
//	if (length(point_C - pixel_pos) < 2.0) { drawn = true; COLOR = vec4(0,0,1,1) }
//	if (length(point_D - pixel_pos) < 2.0) { drawn = true; COLOR = vec4(1,1,0,1)}
	
	
	// formula for finding if a point is within a rectangle
	// (0<AM⋅AB<AB⋅AB)∧(0<AM⋅AD<AD⋅AD)
	vec2 AM = pixel_pos - point_A;
	vec2 AB = point_B - point_A;
	vec2 AD = point_D - point_A;
	float AM_dot_AB = dot(AM, AB);
	float AM_dot_AD = dot(AM, AD);
	if ((0.0 <= AM_dot_AB && AM_dot_AB <= dot(AB, AB)) &&
		(0.0 <= AM_dot_AD && AM_dot_AD <= dot(AD, AD))) 
	{
		COLOR = passed_color;
		drawn = true
	}
	
	float d = length(projectile_pos - pixel_pos); // distance of pixel from projectile
	float d2 = length(projectile_prior - pixel_pos); // distance of pixel from prior
	if ((d < radius) || (d2 < radius)) {
		drawn = true;
		COLOR = passed_color;
		if (d < radius - projectile_border) {
			COLOR = passed_color;
		}
	}
	
	if (!drawn) {
		discard;
	}
}"

[sub_resource type="ShaderMaterial" id=4]
shader = SubResource( 3 )
shader_param/velocity = null
shader_param/passed_color = null
shader_param/radius = null

[sub_resource type="ImageTexture" id=5]
flags = 0
flags = 0
size = Vector2( 64, 64 )

[sub_resource type="ParticlesMaterial" id=2]
flag_disable_z = true
spread = 30.0
gravity = Vector3( 0, 0, 0 )
initial_velocity_random = 0.5
orbit_velocity = 0.0
orbit_velocity_random = 0.0

[node name="Projectile" type="Sprite"]
material = SubResource( 4 )
texture = SubResource( 5 )
script = ExtResource( 1 )

[node name="collisionfx" type="Particles2D" parent="."]
emitting = false
amount = 4
lifetime = 0.2
one_shot = true
explosiveness = 0.75
process_material = SubResource( 2 )
texture = ExtResource( 2 )
script = ExtResource( 5 )

[node name="Tween" type="Tween" parent="."]
